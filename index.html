<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Picker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            overflow: hidden;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
            border-bottom: 2px solid #0f3460;
        }

        #toolbar h1 {
            font-size: 18px;
            color: #e94560;
        }

        #info {
            font-size: 14px;
            color: #aaa;
        }

        #coords {
            font-family: monospace;
            background: #0f3460;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        #zoomLevel {
            font-family: monospace;
            color: #4ecca3;
        }

        #output {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 10px 20px;
            border-top: 2px solid #0f3460;
            z-index: 100;
        }

        #output h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #4ecca3;
        }

        #selections {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 100px;
            overflow-y: auto;
        }

        .selection-item {
            background: #0f3460;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selection-item:hover {
            background: #1a4a7a;
        }

        .selection-item .name {
            color: #4ecca3;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .selection-item .name:hover {
            background: rgba(78, 204, 163, 0.2);
        }

        .selection-item .coords {
            color: #aaa;
            cursor: pointer;
        }

        .selection-item .coords:hover {
            color: #fff;
        }

        .selection-item .btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .selection-item .btn:hover {
            opacity: 1;
        }

        .selection-item .duplicate-btn {
            color: #4ecca3;
        }

        .selection-item .delete-btn {
            color: #e94560;
        }

        #copyAll {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: auto;
        }

        #copyAll:hover {
            background: #3db892;
        }

        #clearAll {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #autoDetect {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #4ecca3;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #autoDetect:hover {
            background: #1a4a7a;
        }

        #formatToggle {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #4ecca3;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: monospace;
            font-size: 12px;
        }

        #formatToggle:hover {
            background: #1a4a7a;
        }

        .format-label {
            color: #aaa;
            font-size: 12px;
        }

        #canvasContainer {
            position: fixed;
            top: 50px;
            bottom: 140px;
            left: 0;
            right: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        #dropZone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px dashed #4ecca3;
            border-radius: 20px;
            padding: 60px;
            text-align: center;
            color: #4ecca3;
            cursor: pointer;
            z-index: 50;
        }

        #dropZone:hover {
            background: rgba(78, 204, 163, 0.1);
            border-color: #e94560;
        }

        #dropZone.hidden {
            display: none;
        }

        #dropZone h2 {
            margin-bottom: 10px;
        }

        #canvas {
            position: absolute;
            image-rendering: pixelated;
        }

        #overlayCanvas {
            position: absolute;
            pointer-events: none;
        }

        #toast {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: #4ecca3;
            color: #1a1a2e;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }

        #toast.show {
            opacity: 1;
        }

        #help {
            font-size: 11px;
            color: #888;
        }

        #contextMenu {
            position: fixed;
            background: #16213e;
            border: 1px solid #4ecca3;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 400;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        #contextMenu.show {
            display: block;
        }

        #contextMenu button {
            display: block;
            width: 100%;
            padding: 8px 16px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
        }

        #contextMenu button:hover {
            background: #0f3460;
        }

        #contextDuplicate {
            color: #4ecca3;
        }

        #contextDelete {
            color: #e94560;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <h1>üé® Sprite Picker</h1>
        <span id="info">Drag an image to start</span>
        <span id="coords">X: 0, Y: 0</span>
        <span id="zoomLevel">Zoom: 1x</span>
        <span id="help">Drag: select | Ctrl: auto-detect | Alt: pan | Wheel: zoom | Dblclick label: rename | Ctrl+V: paste</span>
        <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
            <label for="bgOpacity" style="font-size: 11px; color: #888;">BG:</label>
            <input type="range" id="bgOpacity" min="0" max="100" value="50" style="width: 80px; cursor: pointer;">
        </div>
    </div>

    <div id="canvasContainer">
        <div id="dropZone">
            <h2>üìÅ Drag your sprite sheet here</h2>
            <p>or click to select a file</p>
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
        </div>
        <canvas id="canvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <div id="output">
        <div style="display: flex; align-items: center; margin-bottom: 8px; gap: 10px;">
            <h3 style="margin: 0;">Selections</h3>
            <button id="autoDetect">üîç Auto-detect</button>
            <span class="format-label">Format:</span>
            <button id="formatToggle">[x, y, w, h]</button>
            <button id="clearAll">üóë Clear</button>
            <button id="copyAll">üìã Copy All</button>
        </div>
        <div id="selections"></div>
    </div>

    <div id="toast">Copied!</div>

    <div id="contextMenu">
        <button id="contextDuplicate">üìã Duplicate to right</button>
        <button id="contextDelete">üóë Delete sprite</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        const octx = overlay.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const coordsDisplay = document.getElementById('coords');
        const zoomDisplay = document.getElementById('zoomLevel');
        const infoDisplay = document.getElementById('info');
        const selectionsDiv = document.getElementById('selections');
        const copyAllBtn = document.getElementById('copyAll');
        const clearAllBtn = document.getElementById('clearAll');
        const autoDetectBtn = document.getElementById('autoDetect');
        const formatToggleBtn = document.getElementById('formatToggle');
        const toast = document.getElementById('toast');
        const bgOpacitySlider = document.getElementById('bgOpacity');
        const contextMenu = document.getElementById('contextMenu');
        const contextDuplicateBtn = document.getElementById('contextDuplicate');
        const contextDeleteBtn = document.getElementById('contextDelete');

        let img = null;
        let contextMenuTargetIndex = -1;
        let bgOpacity = 0.5;
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isSelecting = false;
        let isCtrlSelecting = false; // Ctrl+drag for auto-detect in area
        let isPanning = false;
        let isDraggingSelection = false;
        let isResizingSelection = false;
        let resizingSelectionIndex = -1;
        let draggedSelectionIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // Coordinate format: 'xywh' or 'xyxy'
        let coordFormat = 'xywh';

        // Store selection origin in IMAGE coordinates (not screen)
        let selStartPixelX = 0;
        let selStartPixelY = 0;
        let selEndPixelX = 0;
        let selEndPixelY = 0;

        let mouseX = 0;
        let mouseY = 0;
        let selections = [];
        let editingSelectionIndex = -1; // For inline renaming
        let inlineEditInput = null; // The input element for inline editing

        // Drag & Drop
        dropZone.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });

        dropZone.addEventListener('mousedown', (e) => {
            e.stopPropagation();
        });

        fileInput.addEventListener('change', e => {
            if (e.target.files && e.target.files[0]) {
                loadImage(e.target.files[0]);
            }
        });

        container.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.style.borderColor = '#e94560';
        });

        container.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#4ecca3';
        });

        container.addEventListener('drop', e => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        // Ctrl+V paste image from clipboard
        document.addEventListener('paste', async (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const blob = item.getAsFile();
                    if (blob) {
                        loadImageFromBlob(blob, 'clipboard-image');
                    }
                    return;
                }
            }
        });

        function loadImageFromBlob(blob, name) {
            const url = URL.createObjectURL(blob);
            img = new Image();
            img.onload = () => {
                dropZone.classList.add('hidden');
                infoDisplay.textContent = `${name} (${img.width}x${img.height})`;

                zoom = 1;
                offsetX = (container.clientWidth - img.width) / 2;
                offsetY = (container.clientHeight - img.height) / 2;

                resizeCanvases();
                draw();
                URL.revokeObjectURL(url);
            };
            img.src = url;
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                img = new Image();
                img.onload = () => {
                    dropZone.classList.add('hidden');
                    infoDisplay.textContent = `${file.name} (${img.width}x${img.height})`;

                    zoom = 1;
                    offsetX = (container.clientWidth - img.width) / 2;
                    offsetY = (container.clientHeight - img.height) / 2;

                    resizeCanvases();
                    draw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvases() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            overlay.width = container.clientWidth;
            overlay.height = container.clientHeight;
        }

        // Find selection under mouse (at its label)
        function findSelectionAtLabel(mx, my) {
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;

                ctx.font = 'bold 12px monospace';
                const textWidth = ctx.measureText(sel.name).width + 8;

                // Label area
                if (mx >= x && mx <= x + textWidth && my >= y - 18 && my <= y - 2) {
                    return i;
                }
            }
            return -1;
        }

        // Find selection under mouse (at its area)
        function findSelectionAtArea(mx, my) {
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                if (mx >= x && mx <= x + w && my >= y && my <= y + h) {
                    return i;
                }
            }
            return -1;
        }

        // Find if mouse is on resize handle (bottom-right corner)
        function findResizeHandle(mx, my) {
            const handleSize = Math.max(5, 3 * zoom);
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                // Bottom-right corner
                const handleX = x + w - handleSize;
                const handleY = y + h - handleSize;

                if (mx >= handleX && mx <= x + w && my >= handleY && my <= y + h) {
                    return i;
                }
            }
            return -1;
        }

        function draw() {
            if (!img) return;

            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Transparency pattern
            const patternSize = Math.max(8, 8 * zoom);
            const imgX = Math.floor(offsetX);
            const imgY = Math.floor(offsetY);
            const imgW = img.width * zoom;
            const imgH = img.height * zoom;

            // Background colors: 0=black, 0.5=original gray checker, 1=white
            // At 0.5: dark=42, light=58 (original values)
            // At 0: dark=0, light=0 (black)
            // At 1: dark=255, light=255 (white)
            let dark, light;
            if (bgOpacity <= 0.5) {
                // 0 to 0.5: black to original
                const t = bgOpacity * 2; // 0 to 1
                dark = Math.round(42 * t);
                light = Math.round(58 * t);
            } else {
                // 0.5 to 1: original to white
                const t = (bgOpacity - 0.5) * 2; // 0 to 1
                dark = Math.round(42 + (255 - 42) * t);
                light = Math.round(58 + (255 - 58) * t);
            }
            ctx.fillStyle = `rgb(${dark}, ${dark}, ${Math.min(255, dark + 16)})`;
            ctx.fillRect(imgX, imgY, imgW, imgH);
            ctx.fillStyle = `rgb(${light}, ${light}, ${Math.min(255, light + 16)})`;
            for (let y = 0; y < imgH; y += patternSize * 2) {
                for (let x = 0; x < imgW; x += patternSize * 2) {
                    ctx.fillRect(imgX + x, imgY + y, patternSize, patternSize);
                    ctx.fillRect(imgX + x + patternSize, imgY + y + patternSize, patternSize, patternSize);
                }
            }

            // Draw image
            ctx.drawImage(img, offsetX, offsetY, img.width * zoom, img.height * zoom);

            // Pixel grid if zoom >= 6
            if (zoom >= 6) {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;

                for (let x = 0; x <= img.width; x++) {
                    const screenX = Math.floor(offsetX + x * zoom) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(screenX, offsetY);
                    ctx.lineTo(screenX, offsetY + img.height * zoom);
                    ctx.stroke();
                }

                for (let y = 0; y <= img.height; y++) {
                    const screenY = Math.floor(offsetY + y * zoom) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, screenY);
                    ctx.lineTo(offsetX + img.width * zoom, screenY);
                    ctx.stroke();
                }
            }

            // Draw saved selections
            selections.forEach((sel, i) => {
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                // Semi-transparent background
                const isActive = i === draggedSelectionIndex || i === resizingSelectionIndex;
                ctx.fillStyle = isActive ? 'rgba(233, 69, 96, 0.3)' : 'rgba(78, 204, 163, 0.3)';
                ctx.fillRect(x, y, w, h);

                // Border
                ctx.strokeStyle = isActive ? '#e94560' : '#4ecca3';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Resize handle (bottom-right corner)
                const handleSize = Math.max(5, 3 * zoom);
                ctx.fillStyle = isActive ? '#e94560' : '#4ecca3';
                ctx.beginPath();
                ctx.moveTo(x + w, y + h);
                ctx.lineTo(x + w - handleSize, y + h);
                ctx.lineTo(x + w, y + h - handleSize);
                ctx.closePath();
                ctx.fill();

                // Label with name
                ctx.font = 'bold 12px monospace';
                const labelText = sel.name;
                const textWidth = ctx.measureText(labelText).width + 8;
                ctx.fillStyle = isActive ? '#e94560' : '#16213e';
                ctx.fillRect(x, y - 18, textWidth, 16);
                ctx.fillStyle = isActive ? '#fff' : '#4ecca3';
                ctx.fillText(labelText, x + 4, y - 6);
            });
        }

        function drawOverlay() {
            octx.clearRect(0, 0, overlay.width, overlay.height);

            if (!img) return;

            // Guide lines (red cross)
            octx.strokeStyle = 'rgba(233, 69, 96, 0.8)';
            octx.lineWidth = 1;

            octx.beginPath();
            octx.moveTo(0, mouseY + 0.5);
            octx.lineTo(overlay.width, mouseY + 0.5);
            octx.stroke();

            octx.beginPath();
            octx.moveTo(mouseX + 0.5, 0);
            octx.lineTo(mouseX + 0.5, overlay.height);
            octx.stroke();

            // Current selection (using image coordinates)
            if (isSelecting || isCtrlSelecting) {
                const x1 = offsetX + selStartPixelX * zoom;
                const y1 = offsetY + selStartPixelY * zoom;
                const x2 = offsetX + selEndPixelX * zoom;
                const y2 = offsetY + selEndPixelY * zoom;

                const x = Math.min(x1, x2);
                const y = Math.min(y1, y2);
                const w = Math.abs(x2 - x1);
                const h = Math.abs(y2 - y1);

                const pixelX = Math.min(selStartPixelX, selEndPixelX);
                const pixelY = Math.min(selStartPixelY, selEndPixelY);
                const pixelW = Math.abs(selEndPixelX - selStartPixelX);
                const pixelH = Math.abs(selEndPixelY - selStartPixelY);

                // Semi-transparent background (different color for Ctrl mode)
                octx.fillStyle = isCtrlSelecting ? 'rgba(78, 204, 163, 0.2)' : 'rgba(233, 69, 96, 0.2)';
                octx.fillRect(x, y, w, h);

                // Border
                octx.strokeStyle = isCtrlSelecting ? '#4ecca3' : '#e94560';
                octx.lineWidth = 2;
                octx.setLineDash(isCtrlSelecting ? [5, 5] : []);
                octx.strokeRect(x, y, w, h);
                octx.setLineDash([]);

                // Label with info
                octx.fillStyle = isCtrlSelecting ? '#4ecca3' : '#e94560';
                octx.font = 'bold 14px monospace';
                const label = isCtrlSelecting ? `Auto: ${formatCoords(pixelX, pixelY, pixelW, pixelH)}` : formatCoords(pixelX, pixelY, pixelW, pixelH);
                octx.fillText(label, x, y - 8);
            }
        }

        function formatCoords(x, y, w, h) {
            if (coordFormat === 'xyxy') {
                return `[${x}, ${y}, ${x + w}, ${y + h}]`;
            }
            return `[${x}, ${y}, ${w}, ${h}]`;
        }

        // Mouse events
        container.addEventListener('mousemove', e => {
            const rect = container.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            const pixelX = Math.floor((mouseX - offsetX) / zoom);
            const pixelY = Math.floor((mouseY - offsetY) / zoom);
            coordsDisplay.textContent = `X: ${pixelX}, Y: ${pixelY}`;

            // Check for resize handle first
            const resizeIndex = findResizeHandle(mouseX, mouseY);
            const labelIndex = findSelectionAtLabel(mouseX, mouseY);

            // Change cursor based on what's under it
            if (resizeIndex >= 0 && !isSelecting && !isPanning && !isDraggingSelection) {
                container.style.cursor = 'nwse-resize';
            } else if (labelIndex >= 0 && !isSelecting && !isPanning && !isResizingSelection) {
                container.style.cursor = 'move';
            } else if (!isSelecting && !isPanning && !isDraggingSelection && !isResizingSelection) {
                container.style.cursor = 'crosshair';
            }

            // Alt key pressed during selection = pan mode
            if (e.altKey && (isSelecting || isCtrlSelecting || isDraggingSelection || isResizingSelection)) {
                offsetX += e.movementX;
                offsetY += e.movementY;
                draw();
                drawOverlay();
                return;
            }

            if (isPanning) {
                offsetX += e.movementX;
                offsetY += e.movementY;
                draw();
            }

            if (isDraggingSelection && draggedSelectionIndex >= 0) {
                const sel = selections[draggedSelectionIndex];
                sel.x = Math.round(pixelX - dragOffsetX);
                sel.y = Math.round(pixelY - dragOffsetY);

                // Clamp inside image
                sel.x = Math.max(0, Math.min(img.width - sel.w, sel.x));
                sel.y = Math.max(0, Math.min(img.height - sel.h, sel.y));

                updateSelectionsUI();
                draw();
            }

            if (isResizingSelection && resizingSelectionIndex >= 0) {
                const sel = selections[resizingSelectionIndex];
                const newW = Math.round(pixelX - sel.x);
                const newH = Math.round(pixelY - sel.y);

                // Minimum size of 1 pixel
                sel.w = Math.max(1, Math.min(img.width - sel.x, newW));
                sel.h = Math.max(1, Math.min(img.height - sel.y, newH));

                updateSelectionsUI();
                draw();
            }

            if (isSelecting || isCtrlSelecting) {
                // Update selection end in image coordinates
                selEndPixelX = Math.round((mouseX - offsetX) / zoom);
                selEndPixelY = Math.round((mouseY - offsetY) / zoom);
            }

            drawOverlay();
        });

        container.addEventListener('mousedown', e => {
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            if (e.button === 1 || (e.button === 0 && e.altKey)) {
                // Pan (always available with Alt, even while selecting)
                isPanning = true;
                container.style.cursor = 'grabbing';
                e.preventDefault();
            } else if (e.button === 0) {
                // Check for resize handle first
                const resizeIndex = findResizeHandle(mx, my);
                if (resizeIndex >= 0) {
                    isResizingSelection = true;
                    resizingSelectionIndex = resizeIndex;
                    container.style.cursor = 'nwse-resize';
                    draw();
                    return;
                }

                // Check if click on selection label
                const labelIndex = findSelectionAtLabel(mx, my);
                if (labelIndex >= 0) {
                    // Start dragging selection
                    isDraggingSelection = true;
                    draggedSelectionIndex = labelIndex;
                    const sel = selections[labelIndex];
                    const pixelX = Math.floor((mx - offsetX) / zoom);
                    const pixelY = Math.floor((my - offsetY) / zoom);
                    dragOffsetX = pixelX - sel.x;
                    dragOffsetY = pixelY - sel.y;
                    container.style.cursor = 'move';
                    draw();
                } else if (e.ctrlKey) {
                    // Ctrl+click/drag for auto-detect sprites
                    isCtrlSelecting = true;
                    selStartPixelX = Math.round((mx - offsetX) / zoom);
                    selStartPixelY = Math.round((my - offsetY) / zoom);
                    selEndPixelX = selStartPixelX;
                    selEndPixelY = selStartPixelY;
                } else {
                    // New selection - save in IMAGE coordinates
                    isSelecting = true;
                    selStartPixelX = Math.round((mx - offsetX) / zoom);
                    selStartPixelY = Math.round((my - offsetY) / zoom);
                    selEndPixelX = selStartPixelX;
                    selEndPixelY = selStartPixelY;
                }
            }
        });

        // Allow Alt to trigger pan even during selection
        document.addEventListener('keydown', e => {
            if (e.key === 'Alt' && isSelecting && !isPanning) {
                // We'll handle this via the mousedown alt check
            }
        });

        container.addEventListener('mouseup', e => {
            if (isPanning) {
                isPanning = false;
                container.style.cursor = 'crosshair';
            }

            if (isDraggingSelection) {
                isDraggingSelection = false;
                draggedSelectionIndex = -1;
                container.style.cursor = 'crosshair';
                draw();
            }

            if (isResizingSelection) {
                isResizingSelection = false;
                resizingSelectionIndex = -1;
                container.style.cursor = 'crosshair';
                draw();
            }

            if (isCtrlSelecting) {
                isCtrlSelecting = false;

                const x = Math.min(selStartPixelX, selEndPixelX);
                const y = Math.min(selStartPixelY, selEndPixelY);
                const w = Math.abs(selEndPixelX - selStartPixelX);
                const h = Math.abs(selEndPixelY - selStartPixelY);

                if (w > 1 && h > 1) {
                    // Ctrl+drag: detect all sprites in area and merge bounds
                    const detected = detectSpritesInArea(x, y, w, h);
                    if (detected) {
                        addSelection(detected.x, detected.y, detected.w, detected.h);
                    } else {
                        showToast('No sprites detected in area');
                    }
                } else if (img) {
                    // Ctrl+click: detect single sprite at this pixel
                    const clickX = selStartPixelX;
                    const clickY = selStartPixelY;

                    if (clickX >= 0 && clickX < img.width && clickY >= 0 && clickY < img.height) {
                        const detected = detectSpriteAt(clickX, clickY);
                        if (detected) {
                            addSelection(detected.x, detected.y, detected.w, detected.h);
                        } else {
                            showToast('No sprite at this position');
                        }
                    }
                }

                drawOverlay();
            }

            if (isSelecting) {
                isSelecting = false;

                const x = Math.min(selStartPixelX, selEndPixelX);
                const y = Math.min(selStartPixelY, selEndPixelY);
                const w = Math.abs(selEndPixelX - selStartPixelX);
                const h = Math.abs(selEndPixelY - selStartPixelY);

                if (w > 1 && h > 1) {
                    // Normal drag selection - add immediately with auto name
                    addSelection(x, y, w, h);
                }

                drawOverlay();
            }
        });

        container.addEventListener('mouseleave', () => {
            isPanning = false;
            container.style.cursor = 'crosshair';
            octx.clearRect(0, 0, overlay.width, overlay.height);
        });

        // Add a new selection with auto-generated name
        function addSelection(x, y, w, h) {
            selections.push({
                name: `sprite${selections.length + 1}`,
                x, y, w, h
            });
            updateSelectionsUI();
            draw();
        }

        // Double click to rename inline
        container.addEventListener('dblclick', e => {
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const labelIndex = findSelectionAtLabel(mx, my);
            if (labelIndex >= 0) {
                startInlineEdit(labelIndex);
            }
        });

        function startInlineEdit(index) {
            // Remove any existing inline edit
            cancelInlineEdit();

            editingSelectionIndex = index;
            const sel = selections[index];

            // Calculate position of the label
            const x = offsetX + sel.x * zoom;
            const y = offsetY + sel.y * zoom;

            // Create input element
            inlineEditInput = document.createElement('input');
            inlineEditInput.type = 'text';
            inlineEditInput.value = sel.name;
            inlineEditInput.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y - 20}px;
                font: bold 12px monospace;
                background: #16213e;
                color: #4ecca3;
                border: 2px solid #4ecca3;
                padding: 2px 4px;
                border-radius: 2px;
                outline: none;
                z-index: 200;
                min-width: 60px;
            `;

            inlineEditInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    finishInlineEdit();
                } else if (e.key === 'Escape') {
                    cancelInlineEdit();
                }
                e.stopPropagation();
            });

            inlineEditInput.addEventListener('blur', () => {
                finishInlineEdit();
            });

            container.appendChild(inlineEditInput);
            inlineEditInput.focus();
            inlineEditInput.select();
        }

        function finishInlineEdit() {
            if (inlineEditInput && editingSelectionIndex >= 0) {
                const newName = inlineEditInput.value.trim();
                if (newName) {
                    selections[editingSelectionIndex].name = newName;
                    updateSelectionsUI();
                    draw();
                }
            }
            cancelInlineEdit();
        }

        function cancelInlineEdit() {
            if (inlineEditInput && inlineEditInput.parentNode) {
                inlineEditInput.parentNode.removeChild(inlineEditInput);
            }
            inlineEditInput = null;
            editingSelectionIndex = -1;
        }

        // Zoom with wheel - maintains selection origin
        container.addEventListener('wheel', e => {
            e.preventDefault();

            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const imgX = (mx - offsetX) / zoom;
            const imgY = (my - offsetY) / zoom;

            const delta = e.deltaY > 0 ? 0.8 : 1.25;
            const newZoom = Math.max(0.25, Math.min(64, zoom * delta));

            offsetX = mx - imgX * newZoom;
            offsetY = my - imgY * newZoom;
            zoom = newZoom;

            zoomDisplay.textContent = `Zoom: ${zoom.toFixed(1)}x`;
            draw();
            drawOverlay();
        });

        // Format toggle button
        formatToggleBtn.addEventListener('click', () => {
            coordFormat = coordFormat === 'xywh' ? 'xyxy' : 'xywh';
            formatToggleBtn.textContent = coordFormat === 'xywh' ? '[x, y, w, h]' : '[x1, y1, x2, y2]';
            updateSelectionsUI();
        });

        // Background opacity slider
        bgOpacitySlider.addEventListener('input', () => {
            bgOpacity = bgOpacitySlider.value / 100;
            draw();
        });

        function updateSelectionsUI() {
            selectionsDiv.innerHTML = '';
            selections.forEach((sel, i) => {
                const div = document.createElement('div');
                div.className = 'selection-item';

                // Name (double click to edit inline)
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = sel.name;
                nameSpan.title = 'Double-click to rename';
                nameSpan.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    // Create inline input in the selections panel
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = sel.name;
                    input.style.cssText = `
                        font: inherit;
                        background: #1a1a2e;
                        color: #4ecca3;
                        border: 1px solid #4ecca3;
                        padding: 2px 4px;
                        border-radius: 2px;
                        outline: none;
                        width: 80px;
                    `;
                    input.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            const newName = input.value.trim();
                            if (newName) {
                                selections[i].name = newName;
                            }
                            updateSelectionsUI();
                            draw();
                        } else if (ev.key === 'Escape') {
                            updateSelectionsUI();
                        }
                        ev.stopPropagation();
                    });
                    input.addEventListener('blur', () => {
                        const newName = input.value.trim();
                        if (newName) {
                            selections[i].name = newName;
                        }
                        updateSelectionsUI();
                        draw();
                    });
                    nameSpan.textContent = '';
                    nameSpan.appendChild(input);
                    input.focus();
                    input.select();
                });

                // Coordinates (click to copy)
                const coordsSpan = document.createElement('span');
                coordsSpan.className = 'coords';
                coordsSpan.textContent = formatCoords(sel.x, sel.y, sel.w, sel.h);
                coordsSpan.title = 'Click to copy';
                coordsSpan.addEventListener('click', () => {
                    copyToClipboard(`${sel.name}: ${formatCoords(sel.x, sel.y, sel.w, sel.h)},`);
                });

                // Duplicate (place to the right)
                const duplicateBtn = document.createElement('button');
                duplicateBtn.className = 'btn duplicate-btn';
                duplicateBtn.textContent = 'üìã';
                duplicateBtn.title = 'Duplicate to right';
                duplicateBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newX = sel.x + sel.w;
                    // Clamp to image bounds
                    const clampedX = img ? Math.min(newX, img.width - sel.w) : newX;
                    const newSel = {
                        ...sel,
                        name: sel.name + '_copy',
                        x: clampedX
                    };
                    selections.push(newSel);
                    updateSelectionsUI();
                    draw();
                    showToast('Duplicated to right');
                });

                // Delete
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn delete-btn';
                deleteBtn.textContent = 'üóë';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selections.splice(i, 1);
                    updateSelectionsUI();
                    draw();
                    showToast('Selection deleted');
                });

                div.appendChild(nameSpan);
                div.appendChild(coordsSpan);
                div.appendChild(duplicateBtn);
                div.appendChild(deleteBtn);
                selectionsDiv.appendChild(div);
            });
        }

        copyAllBtn.addEventListener('click', () => {
            if (selections.length === 0) {
                showToast('No selections');
                return;
            }

            const text = selections.map(sel =>
                `    ${sel.name}: ${formatCoords(sel.x, sel.y, sel.w, sel.h)},`
            ).join('\n');

            copyToClipboard(`const spriteRegions = {\n${text}\n};`);
        });

        clearAllBtn.addEventListener('click', () => {
            if (selections.length === 0) return;
            if (confirm('Delete all selections?')) {
                selections = [];
                updateSelectionsUI();
                draw();
                showToast('Selections cleared');
            }
        });

        // Detect sprite at a specific pixel using flood fill
        function detectSpriteAt(clickX, clickY) {
            if (!img) return null;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            // Check if clicked pixel is transparent
            const clickIdx = (clickY * img.width + clickX) * 4;
            if (data[clickIdx + 3] < 128) {
                return null; // Clicked on transparent pixel
            }

            const visited = new Array(img.width * img.height).fill(false);

            function isTransparent(x, y) {
                if (x < 0 || x >= img.width || y < 0 || y >= img.height) return true;
                const idx = (y * img.width + x) * 4;
                return data[idx + 3] < 128;
            }

            const stack = [[clickX, clickY]];
            let minX = clickX, maxX = clickX, minY = clickY, maxY = clickY;

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const idx = y * img.width + x;

                if (x < 0 || x >= img.width || y < 0 || y >= img.height) continue;
                if (visited[idx]) continue;
                if (isTransparent(x, y)) continue;

                visited[idx] = true;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            const w = maxX - minX + 1;
            const h = maxY - minY + 1;

            if (w >= 2 && h >= 2) {
                return { x: minX, y: minY, w, h };
            }
            return null;
        }

        // Detect all sprites within an area and merge their bounds
        function detectSpritesInArea(areaX, areaY, areaW, areaH) {
            if (!img) return null;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            const visited = new Array(img.width * img.height).fill(false);

            function isTransparent(x, y) {
                if (x < 0 || x >= img.width || y < 0 || y >= img.height) return true;
                const idx = (y * img.width + x) * 4;
                return data[idx + 3] < 128;
            }

            // Flood fill from a starting point
            function floodFill(startX, startY) {
                const stack = [[startX, startY]];
                let minX = startX, maxX = startX, minY = startY, maxY = startY;

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * img.width + x;

                    if (x < 0 || x >= img.width || y < 0 || y >= img.height) continue;
                    if (visited[idx]) continue;
                    if (isTransparent(x, y)) continue;

                    visited[idx] = true;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);

                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }

                return { minX, maxX, minY, maxY };
            }

            // Clamp area to image bounds
            const startX = Math.max(0, areaX);
            const startY = Math.max(0, areaY);
            const endX = Math.min(img.width, areaX + areaW);
            const endY = Math.min(img.height, areaY + areaH);

            // Find all sprites that touch the area
            let globalMinX = Infinity, globalMaxX = -Infinity;
            let globalMinY = Infinity, globalMaxY = -Infinity;
            let foundAny = false;

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = y * img.width + x;
                    if (!visited[idx] && !isTransparent(x, y)) {
                        const bounds = floodFill(x, y);
                        const w = bounds.maxX - bounds.minX + 1;
                        const h = bounds.maxY - bounds.minY + 1;

                        if (w >= 2 && h >= 2) {
                            globalMinX = Math.min(globalMinX, bounds.minX);
                            globalMaxX = Math.max(globalMaxX, bounds.maxX);
                            globalMinY = Math.min(globalMinY, bounds.minY);
                            globalMaxY = Math.max(globalMaxY, bounds.maxY);
                            foundAny = true;
                        }
                    }
                }
            }

            if (foundAny) {
                return {
                    x: globalMinX,
                    y: globalMinY,
                    w: globalMaxX - globalMinX + 1,
                    h: globalMaxY - globalMinY + 1
                };
            }
            return null;
        }

        // Auto-detect sprites
        autoDetectBtn.addEventListener('click', () => {
            if (!img) {
                showToast('Load an image first');
                return;
            }

            // Create temporary canvas to read pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            // Create visited array
            const visited = new Array(img.width * img.height).fill(false);

            // Check if pixel is transparent (alpha < 128)
            function isTransparent(x, y) {
                if (x < 0 || x >= img.width || y < 0 || y >= img.height) return true;
                const idx = (y * img.width + x) * 4;
                return data[idx + 3] < 128;
            }

            // Flood fill to find connected non-transparent pixels
            function floodFill(startX, startY) {
                const stack = [[startX, startY]];
                let minX = startX, maxX = startX, minY = startY, maxY = startY;

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * img.width + x;

                    if (x < 0 || x >= img.width || y < 0 || y >= img.height) continue;
                    if (visited[idx]) continue;
                    if (isTransparent(x, y)) continue;

                    visited[idx] = true;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);

                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }

                return { minX, maxX, minY, maxY };
            }

            // Find all sprites
            const detectedSprites = [];
            for (let y = 0; y < img.height; y++) {
                for (let x = 0; x < img.width; x++) {
                    const idx = y * img.width + x;
                    if (!visited[idx] && !isTransparent(x, y)) {
                        const bounds = floodFill(x, y);
                        const w = bounds.maxX - bounds.minX + 1;
                        const h = bounds.maxY - bounds.minY + 1;
                        // Filter out very small sprites (noise)
                        if (w >= 2 && h >= 2) {
                            detectedSprites.push({
                                name: `sprite${selections.length + detectedSprites.length + 1}`,
                                x: bounds.minX,
                                y: bounds.minY,
                                w: w,
                                h: h
                            });
                        }
                    }
                }
            }

            if (detectedSprites.length === 0) {
                showToast('No sprites detected');
                return;
            }

            // Add detected sprites to selections
            selections.push(...detectedSprites);
            updateSelectionsUI();
            draw();
            showToast(`Detected ${detectedSprites.length} sprites`);
        });

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('Copied!');
                }).catch(() => fallbackCopy(text));
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('Copied!');
            } catch (err) {
                showToast('Copy failed');
            }
            document.body.removeChild(textarea);
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        window.addEventListener('resize', () => {
            resizeCanvases();
            draw();
        });

        // Right-click context menu
        container.addEventListener('contextmenu', e => {
            e.preventDefault();
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const labelIndex = findSelectionAtLabel(mx, my);
            if (labelIndex >= 0) {
                contextMenuTargetIndex = labelIndex;
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('show');
            } else {
                hideContextMenu();
            }
        });

        function hideContextMenu() {
            contextMenu.classList.remove('show');
            contextMenuTargetIndex = -1;
        }

        // Hide context menu on click elsewhere
        document.addEventListener('click', () => {
            hideContextMenu();
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                hideContextMenu();
            }
        });

        contextDuplicateBtn.addEventListener('click', () => {
            if (contextMenuTargetIndex >= 0) {
                const sel = selections[contextMenuTargetIndex];
                const newX = sel.x + sel.w;
                const clampedX = img ? Math.min(newX, img.width - sel.w) : newX;
                const newSel = {
                    ...sel,
                    name: sel.name + '_copy',
                    x: clampedX
                };
                selections.push(newSel);
                updateSelectionsUI();
                draw();
                showToast('Duplicated to right');
            }
            hideContextMenu();
        });

        contextDeleteBtn.addEventListener('click', () => {
            if (contextMenuTargetIndex >= 0) {
                selections.splice(contextMenuTargetIndex, 1);
                updateSelectionsUI();
                draw();
                showToast('Sprite deleted');
            }
            hideContextMenu();
        });

        resizeCanvases();
    </script>
</body>
</html>
