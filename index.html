<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Picker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            overflow: hidden;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
            border-bottom: 2px solid #0f3460;
        }

        #toolbar h1 {
            font-size: 18px;
            color: #e94560;
        }

        #info {
            font-size: 14px;
            color: #aaa;
        }

        #coords {
            font-family: monospace;
            background: #0f3460;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        #zoomLevel {
            font-family: monospace;
            color: #4ecca3;
        }

        #output {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 10px 20px;
            border-top: 2px solid #0f3460;
            z-index: 100;
        }

        #output h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #4ecca3;
        }

        #selections {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 100px;
            overflow-y: auto;
        }

        .selection-item {
            background: #0f3460;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selection-item:hover {
            background: #1a4a7a;
        }

        .selection-item .name {
            color: #4ecca3;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .selection-item .name:hover {
            background: rgba(78, 204, 163, 0.2);
        }

        .selection-item .coords {
            color: #aaa;
            cursor: pointer;
        }

        .selection-item .coords:hover {
            color: #fff;
        }

        .selection-item .btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .selection-item .btn:hover {
            opacity: 1;
        }

        .selection-item .duplicate-btn {
            color: #4ecca3;
        }

        .selection-item .delete-btn {
            color: #e94560;
        }

        #copyAll {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: auto;
        }

        #copyAll:hover {
            background: #3db892;
        }

        #clearAll {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #formatToggle {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #4ecca3;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: monospace;
            font-size: 12px;
        }

        #formatToggle:hover {
            background: #1a4a7a;
        }

        .format-label {
            color: #aaa;
            font-size: 12px;
        }

        #canvasContainer {
            position: fixed;
            top: 50px;
            bottom: 140px;
            left: 0;
            right: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        #dropZone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px dashed #4ecca3;
            border-radius: 20px;
            padding: 60px;
            text-align: center;
            color: #4ecca3;
            cursor: pointer;
            z-index: 50;
        }

        #dropZone:hover {
            background: rgba(78, 204, 163, 0.1);
            border-color: #e94560;
        }

        #dropZone.hidden {
            display: none;
        }

        #dropZone h2 {
            margin-bottom: 10px;
        }

        #canvas {
            position: absolute;
            image-rendering: pixelated;
        }

        #overlayCanvas {
            position: absolute;
            pointer-events: none;
        }

        #toast {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: #4ecca3;
            color: #1a1a2e;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }

        #toast.show {
            opacity: 1;
        }

        #help {
            font-size: 11px;
            color: #888;
        }

        /* Modal for naming */
        #nameModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #nameModal.show {
            display: flex;
        }

        #nameModal .modal-content {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #4ecca3;
        }

        #nameModal h3 {
            margin-bottom: 15px;
            color: #4ecca3;
        }

        #nameModal input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #eee;
            width: 250px;
            font-family: monospace;
        }

        #nameModal input:focus {
            outline: none;
            border-color: #4ecca3;
        }

        #nameModal .modal-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        #nameModal button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #nameModal .save-btn {
            background: #4ecca3;
            color: #1a1a2e;
        }

        #nameModal .cancel-btn {
            background: #666;
            color: #eee;
        }

        #selectionInfo {
            font-family: monospace;
            color: #aaa;
            margin-bottom: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <h1>üé® Sprite Picker</h1>
        <span id="info">Drag an image to start</span>
        <span id="coords">X: 0, Y: 0</span>
        <span id="zoomLevel">Zoom: 1x</span>
        <span id="help">Wheel: zoom | Drag: select | Click label: move | Dblclick: rename | Alt+Drag: pan | Ctrl+V: paste</span>
        <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
            <label for="bgOpacity" style="font-size: 11px; color: #888;">BG:</label>
            <input type="range" id="bgOpacity" min="0" max="100" value="50" style="width: 80px; cursor: pointer;">
        </div>
    </div>

    <div id="canvasContainer">
        <div id="dropZone">
            <h2>üìÅ Drag your sprite sheet here</h2>
            <p>or click to select a file</p>
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
        </div>
        <canvas id="canvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <div id="output">
        <div style="display: flex; align-items: center; margin-bottom: 8px; gap: 10px;">
            <h3 style="margin: 0;">Selections</h3>
            <span class="format-label">Format:</span>
            <button id="formatToggle">[x, y, w, h]</button>
            <button id="clearAll">üóë Clear</button>
            <button id="copyAll">üìã Copy All</button>
        </div>
        <div id="selections"></div>
    </div>

    <div id="toast">Copied!</div>

    <div id="nameModal">
        <div class="modal-content">
            <h3 id="modalTitle">Sprite Name</h3>
            <div id="selectionInfo"></div>
            <input type="text" id="spriteName" placeholder="e.g.: bird, pipe, ground...">
            <div class="modal-buttons">
                <button class="cancel-btn" id="cancelName">Cancel</button>
                <button class="save-btn" id="saveName">Save</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        const octx = overlay.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const coordsDisplay = document.getElementById('coords');
        const zoomDisplay = document.getElementById('zoomLevel');
        const infoDisplay = document.getElementById('info');
        const selectionsDiv = document.getElementById('selections');
        const copyAllBtn = document.getElementById('copyAll');
        const clearAllBtn = document.getElementById('clearAll');
        const formatToggleBtn = document.getElementById('formatToggle');
        const toast = document.getElementById('toast');
        const nameModal = document.getElementById('nameModal');
        const modalTitle = document.getElementById('modalTitle');
        const spriteNameInput = document.getElementById('spriteName');
        const selectionInfoDiv = document.getElementById('selectionInfo');
        const saveNameBtn = document.getElementById('saveName');
        const cancelNameBtn = document.getElementById('cancelName');
        const bgOpacitySlider = document.getElementById('bgOpacity');

        let img = null;
        let bgOpacity = 0.5;
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isSelecting = false;
        let isPanning = false;
        let isDraggingSelection = false;
        let isResizingSelection = false;
        let resizingSelectionIndex = -1;
        let draggedSelectionIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // Coordinate format: 'xywh' or 'xyxy'
        let coordFormat = 'xywh';

        // Store selection origin in IMAGE coordinates (not screen)
        let selStartPixelX = 0;
        let selStartPixelY = 0;
        let selEndPixelX = 0;
        let selEndPixelY = 0;

        let mouseX = 0;
        let mouseY = 0;
        let selections = [];
        let pendingSelection = null;
        let editingSelectionIndex = -1; // For renaming

        // Drag & Drop
        dropZone.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });

        dropZone.addEventListener('mousedown', (e) => {
            e.stopPropagation();
        });

        fileInput.addEventListener('change', e => {
            if (e.target.files && e.target.files[0]) {
                loadImage(e.target.files[0]);
            }
        });

        container.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.style.borderColor = '#e94560';
        });

        container.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#4ecca3';
        });

        container.addEventListener('drop', e => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        // Ctrl+V paste image from clipboard
        document.addEventListener('paste', async (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const blob = item.getAsFile();
                    if (blob) {
                        loadImageFromBlob(blob, 'clipboard-image');
                    }
                    return;
                }
            }
        });

        function loadImageFromBlob(blob, name) {
            const url = URL.createObjectURL(blob);
            img = new Image();
            img.onload = () => {
                dropZone.classList.add('hidden');
                infoDisplay.textContent = `${name} (${img.width}x${img.height})`;

                zoom = 1;
                offsetX = (container.clientWidth - img.width) / 2;
                offsetY = (container.clientHeight - img.height) / 2;

                resizeCanvases();
                draw();
                URL.revokeObjectURL(url);
            };
            img.src = url;
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                img = new Image();
                img.onload = () => {
                    dropZone.classList.add('hidden');
                    infoDisplay.textContent = `${file.name} (${img.width}x${img.height})`;

                    zoom = 1;
                    offsetX = (container.clientWidth - img.width) / 2;
                    offsetY = (container.clientHeight - img.height) / 2;

                    resizeCanvases();
                    draw();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvases() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            overlay.width = container.clientWidth;
            overlay.height = container.clientHeight;
        }

        // Find selection under mouse (at its label)
        function findSelectionAtLabel(mx, my) {
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;

                ctx.font = 'bold 12px monospace';
                const textWidth = ctx.measureText(sel.name).width + 8;

                // Label area
                if (mx >= x && mx <= x + textWidth && my >= y - 18 && my <= y - 2) {
                    return i;
                }
            }
            return -1;
        }

        // Find selection under mouse (at its area)
        function findSelectionAtArea(mx, my) {
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                if (mx >= x && mx <= x + w && my >= y && my <= y + h) {
                    return i;
                }
            }
            return -1;
        }

        // Find if mouse is on resize handle (bottom-right corner)
        function findResizeHandle(mx, my) {
            const handleSize = Math.max(5, 3 * zoom);
            for (let i = selections.length - 1; i >= 0; i--) {
                const sel = selections[i];
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                // Bottom-right corner
                const handleX = x + w - handleSize;
                const handleY = y + h - handleSize;

                if (mx >= handleX && mx <= x + w && my >= handleY && my <= y + h) {
                    return i;
                }
            }
            return -1;
        }

        function draw() {
            if (!img) return;

            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Transparency pattern
            const patternSize = Math.max(8, 8 * zoom);
            const imgX = Math.floor(offsetX);
            const imgY = Math.floor(offsetY);
            const imgW = img.width * zoom;
            const imgH = img.height * zoom;

            // Background colors: 0=black, 0.5=original gray checker, 1=white
            // At 0.5: dark=42, light=58 (original values)
            // At 0: dark=0, light=0 (black)
            // At 1: dark=255, light=255 (white)
            let dark, light;
            if (bgOpacity <= 0.5) {
                // 0 to 0.5: black to original
                const t = bgOpacity * 2; // 0 to 1
                dark = Math.round(42 * t);
                light = Math.round(58 * t);
            } else {
                // 0.5 to 1: original to white
                const t = (bgOpacity - 0.5) * 2; // 0 to 1
                dark = Math.round(42 + (255 - 42) * t);
                light = Math.round(58 + (255 - 58) * t);
            }
            ctx.fillStyle = `rgb(${dark}, ${dark}, ${Math.min(255, dark + 16)})`;
            ctx.fillRect(imgX, imgY, imgW, imgH);
            ctx.fillStyle = `rgb(${light}, ${light}, ${Math.min(255, light + 16)})`;
            for (let y = 0; y < imgH; y += patternSize * 2) {
                for (let x = 0; x < imgW; x += patternSize * 2) {
                    ctx.fillRect(imgX + x, imgY + y, patternSize, patternSize);
                    ctx.fillRect(imgX + x + patternSize, imgY + y + patternSize, patternSize, patternSize);
                }
            }

            // Draw image
            ctx.drawImage(img, offsetX, offsetY, img.width * zoom, img.height * zoom);

            // Pixel grid if zoom >= 6
            if (zoom >= 6) {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;

                for (let x = 0; x <= img.width; x++) {
                    const screenX = Math.floor(offsetX + x * zoom) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(screenX, offsetY);
                    ctx.lineTo(screenX, offsetY + img.height * zoom);
                    ctx.stroke();
                }

                for (let y = 0; y <= img.height; y++) {
                    const screenY = Math.floor(offsetY + y * zoom) + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, screenY);
                    ctx.lineTo(offsetX + img.width * zoom, screenY);
                    ctx.stroke();
                }
            }

            // Draw saved selections
            selections.forEach((sel, i) => {
                const x = offsetX + sel.x * zoom;
                const y = offsetY + sel.y * zoom;
                const w = sel.w * zoom;
                const h = sel.h * zoom;

                // Semi-transparent background
                const isActive = i === draggedSelectionIndex || i === resizingSelectionIndex;
                ctx.fillStyle = isActive ? 'rgba(233, 69, 96, 0.3)' : 'rgba(78, 204, 163, 0.3)';
                ctx.fillRect(x, y, w, h);

                // Border
                ctx.strokeStyle = isActive ? '#e94560' : '#4ecca3';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Resize handle (bottom-right corner)
                const handleSize = Math.max(5, 3 * zoom);
                ctx.fillStyle = isActive ? '#e94560' : '#4ecca3';
                ctx.beginPath();
                ctx.moveTo(x + w, y + h);
                ctx.lineTo(x + w - handleSize, y + h);
                ctx.lineTo(x + w, y + h - handleSize);
                ctx.closePath();
                ctx.fill();

                // Label with name
                ctx.font = 'bold 12px monospace';
                const labelText = sel.name;
                const textWidth = ctx.measureText(labelText).width + 8;
                ctx.fillStyle = isActive ? '#e94560' : '#16213e';
                ctx.fillRect(x, y - 18, textWidth, 16);
                ctx.fillStyle = isActive ? '#fff' : '#4ecca3';
                ctx.fillText(labelText, x + 4, y - 6);
            });
        }

        function drawOverlay() {
            octx.clearRect(0, 0, overlay.width, overlay.height);

            if (!img) return;

            // Guide lines (red cross)
            octx.strokeStyle = 'rgba(233, 69, 96, 0.8)';
            octx.lineWidth = 1;

            octx.beginPath();
            octx.moveTo(0, mouseY + 0.5);
            octx.lineTo(overlay.width, mouseY + 0.5);
            octx.stroke();

            octx.beginPath();
            octx.moveTo(mouseX + 0.5, 0);
            octx.lineTo(mouseX + 0.5, overlay.height);
            octx.stroke();

            // Current selection (using image coordinates)
            if (isSelecting) {
                const x1 = offsetX + selStartPixelX * zoom;
                const y1 = offsetY + selStartPixelY * zoom;
                const x2 = offsetX + selEndPixelX * zoom;
                const y2 = offsetY + selEndPixelY * zoom;

                const x = Math.min(x1, x2);
                const y = Math.min(y1, y2);
                const w = Math.abs(x2 - x1);
                const h = Math.abs(y2 - y1);

                const pixelX = Math.min(selStartPixelX, selEndPixelX);
                const pixelY = Math.min(selStartPixelY, selEndPixelY);
                const pixelW = Math.abs(selEndPixelX - selStartPixelX);
                const pixelH = Math.abs(selEndPixelY - selStartPixelY);

                // Semi-transparent background
                octx.fillStyle = 'rgba(233, 69, 96, 0.2)';
                octx.fillRect(x, y, w, h);

                // Border
                octx.strokeStyle = '#e94560';
                octx.lineWidth = 2;
                octx.strokeRect(x, y, w, h);

                // Label with info
                octx.fillStyle = '#e94560';
                octx.font = 'bold 14px monospace';
                const label = formatCoords(pixelX, pixelY, pixelW, pixelH);
                octx.fillText(label, x, y - 8);
            }
        }

        function formatCoords(x, y, w, h) {
            if (coordFormat === 'xyxy') {
                return `[${x}, ${y}, ${x + w}, ${y + h}]`;
            }
            return `[${x}, ${y}, ${w}, ${h}]`;
        }

        // Mouse events
        container.addEventListener('mousemove', e => {
            const rect = container.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            const pixelX = Math.floor((mouseX - offsetX) / zoom);
            const pixelY = Math.floor((mouseY - offsetY) / zoom);
            coordsDisplay.textContent = `X: ${pixelX}, Y: ${pixelY}`;

            // Check for resize handle first
            const resizeIndex = findResizeHandle(mouseX, mouseY);
            const labelIndex = findSelectionAtLabel(mouseX, mouseY);

            // Change cursor based on what's under it
            if (resizeIndex >= 0 && !isSelecting && !isPanning && !isDraggingSelection) {
                container.style.cursor = 'nwse-resize';
            } else if (labelIndex >= 0 && !isSelecting && !isPanning && !isResizingSelection) {
                container.style.cursor = 'move';
            } else if (!isSelecting && !isPanning && !isDraggingSelection && !isResizingSelection) {
                container.style.cursor = 'crosshair';
            }

            // Alt key pressed during selection = pan mode
            if (e.altKey && (isSelecting || isDraggingSelection || isResizingSelection)) {
                offsetX += e.movementX;
                offsetY += e.movementY;
                draw();
                drawOverlay();
                return;
            }

            if (isPanning) {
                offsetX += e.movementX;
                offsetY += e.movementY;
                draw();
            }

            if (isDraggingSelection && draggedSelectionIndex >= 0) {
                const sel = selections[draggedSelectionIndex];
                sel.x = Math.round(pixelX - dragOffsetX);
                sel.y = Math.round(pixelY - dragOffsetY);

                // Clamp inside image
                sel.x = Math.max(0, Math.min(img.width - sel.w, sel.x));
                sel.y = Math.max(0, Math.min(img.height - sel.h, sel.y));

                updateSelectionsUI();
                draw();
            }

            if (isResizingSelection && resizingSelectionIndex >= 0) {
                const sel = selections[resizingSelectionIndex];
                const newW = Math.round(pixelX - sel.x);
                const newH = Math.round(pixelY - sel.y);

                // Minimum size of 1 pixel
                sel.w = Math.max(1, Math.min(img.width - sel.x, newW));
                sel.h = Math.max(1, Math.min(img.height - sel.y, newH));

                updateSelectionsUI();
                draw();
            }

            if (isSelecting) {
                // Update selection end in image coordinates
                selEndPixelX = Math.round((mouseX - offsetX) / zoom);
                selEndPixelY = Math.round((mouseY - offsetY) / zoom);
            }

            drawOverlay();
        });

        container.addEventListener('mousedown', e => {
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            if (e.button === 1 || (e.button === 0 && e.altKey)) {
                // Pan (always available with Alt, even while selecting)
                isPanning = true;
                container.style.cursor = 'grabbing';
                e.preventDefault();
            } else if (e.button === 0) {
                // Check for resize handle first
                const resizeIndex = findResizeHandle(mx, my);
                if (resizeIndex >= 0) {
                    isResizingSelection = true;
                    resizingSelectionIndex = resizeIndex;
                    container.style.cursor = 'nwse-resize';
                    draw();
                    return;
                }

                // Check if click on selection label
                const labelIndex = findSelectionAtLabel(mx, my);
                if (labelIndex >= 0) {
                    // Start dragging selection
                    isDraggingSelection = true;
                    draggedSelectionIndex = labelIndex;
                    const sel = selections[labelIndex];
                    const pixelX = Math.floor((mx - offsetX) / zoom);
                    const pixelY = Math.floor((my - offsetY) / zoom);
                    dragOffsetX = pixelX - sel.x;
                    dragOffsetY = pixelY - sel.y;
                    container.style.cursor = 'move';
                    draw();
                } else {
                    // New selection - save in IMAGE coordinates
                    isSelecting = true;
                    selStartPixelX = Math.round((mx - offsetX) / zoom);
                    selStartPixelY = Math.round((my - offsetY) / zoom);
                    selEndPixelX = selStartPixelX;
                    selEndPixelY = selStartPixelY;
                }
            }
        });

        // Allow Alt to trigger pan even during selection
        document.addEventListener('keydown', e => {
            if (e.key === 'Alt' && isSelecting && !isPanning) {
                // We'll handle this via the mousedown alt check
            }
        });

        container.addEventListener('mouseup', e => {
            if (isPanning) {
                isPanning = false;
                container.style.cursor = 'crosshair';
            }

            if (isDraggingSelection) {
                isDraggingSelection = false;
                draggedSelectionIndex = -1;
                container.style.cursor = 'crosshair';
                draw();
            }

            if (isResizingSelection) {
                isResizingSelection = false;
                resizingSelectionIndex = -1;
                container.style.cursor = 'crosshair';
                draw();
            }

            if (isSelecting) {
                isSelecting = false;

                const x = Math.min(selStartPixelX, selEndPixelX);
                const y = Math.min(selStartPixelY, selEndPixelY);
                const w = Math.abs(selEndPixelX - selStartPixelX);
                const h = Math.abs(selEndPixelY - selStartPixelY);

                if (w > 1 && h > 1) {
                    pendingSelection = { x, y, w, h };
                    editingSelectionIndex = -1;
                    modalTitle.textContent = 'Sprite Name';
                    selectionInfoDiv.textContent = `Coordinates: ${formatCoords(x, y, w, h)}`;
                    spriteNameInput.value = `sprite${selections.length + 1}`;
                    nameModal.classList.add('show');
                    spriteNameInput.focus();
                    spriteNameInput.select();
                }

                drawOverlay();
            }
        });

        container.addEventListener('mouseleave', () => {
            isPanning = false;
            container.style.cursor = 'crosshair';
            octx.clearRect(0, 0, overlay.width, overlay.height);
        });

        // Double click to rename
        container.addEventListener('dblclick', e => {
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const labelIndex = findSelectionAtLabel(mx, my);
            if (labelIndex >= 0) {
                // Rename
                editingSelectionIndex = labelIndex;
                const sel = selections[labelIndex];
                modalTitle.textContent = 'Rename Sprite';
                selectionInfoDiv.textContent = `Coordinates: ${formatCoords(sel.x, sel.y, sel.w, sel.h)}`;
                spriteNameInput.value = sel.name;
                pendingSelection = null;
                nameModal.classList.add('show');
                spriteNameInput.focus();
                spriteNameInput.select();
            }
        });

        // Modal handlers
        saveNameBtn.addEventListener('click', saveSelection);
        cancelNameBtn.addEventListener('click', closeModal);

        spriteNameInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                saveSelection();
            } else if (e.key === 'Escape') {
                closeModal();
            }
        });

        function closeModal() {
            nameModal.classList.remove('show');
            pendingSelection = null;
            editingSelectionIndex = -1;
        }

        function saveSelection() {
            const name = spriteNameInput.value.trim() || `sprite${selections.length + 1}`;

            if (editingSelectionIndex >= 0) {
                // Rename existing
                selections[editingSelectionIndex].name = name;
                showToast('Name updated');
            } else if (pendingSelection) {
                // New selection
                selections.push({
                    name,
                    x: pendingSelection.x,
                    y: pendingSelection.y,
                    w: pendingSelection.w,
                    h: pendingSelection.h
                });
                showToast('Selection saved');
            }

            closeModal();
            updateSelectionsUI();
            draw();
        }

        // Zoom with wheel - maintains selection origin
        container.addEventListener('wheel', e => {
            e.preventDefault();

            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const imgX = (mx - offsetX) / zoom;
            const imgY = (my - offsetY) / zoom;

            const delta = e.deltaY > 0 ? 0.8 : 1.25;
            const newZoom = Math.max(0.25, Math.min(64, zoom * delta));

            offsetX = mx - imgX * newZoom;
            offsetY = my - imgY * newZoom;
            zoom = newZoom;

            zoomDisplay.textContent = `Zoom: ${zoom.toFixed(1)}x`;
            draw();
            drawOverlay();
        });

        // Format toggle button
        formatToggleBtn.addEventListener('click', () => {
            coordFormat = coordFormat === 'xywh' ? 'xyxy' : 'xywh';
            formatToggleBtn.textContent = coordFormat === 'xywh' ? '[x, y, w, h]' : '[x1, y1, x2, y2]';
            updateSelectionsUI();
        });

        // Background opacity slider
        bgOpacitySlider.addEventListener('input', () => {
            bgOpacity = bgOpacitySlider.value / 100;
            draw();
        });

        function updateSelectionsUI() {
            selectionsDiv.innerHTML = '';
            selections.forEach((sel, i) => {
                const div = document.createElement('div');
                div.className = 'selection-item';

                // Name (double click to edit)
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = sel.name;
                nameSpan.title = 'Double-click to rename';
                nameSpan.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editingSelectionIndex = i;
                    modalTitle.textContent = 'Rename Sprite';
                    selectionInfoDiv.textContent = `Coordinates: ${formatCoords(sel.x, sel.y, sel.w, sel.h)}`;
                    spriteNameInput.value = sel.name;
                    pendingSelection = null;
                    nameModal.classList.add('show');
                    spriteNameInput.focus();
                    spriteNameInput.select();
                });

                // Coordinates (click to copy)
                const coordsSpan = document.createElement('span');
                coordsSpan.className = 'coords';
                coordsSpan.textContent = formatCoords(sel.x, sel.y, sel.w, sel.h);
                coordsSpan.title = 'Click to copy';
                coordsSpan.addEventListener('click', () => {
                    copyToClipboard(`${sel.name}: ${formatCoords(sel.x, sel.y, sel.w, sel.h)},`);
                });

                // Duplicate
                const duplicateBtn = document.createElement('button');
                duplicateBtn.className = 'btn duplicate-btn';
                duplicateBtn.textContent = 'üìã';
                duplicateBtn.title = 'Duplicate';
                duplicateBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newSel = { ...sel, name: sel.name + '_copy' };
                    selections.push(newSel);
                    updateSelectionsUI();
                    draw();
                    showToast('Selection duplicated');
                });

                // Delete
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn delete-btn';
                deleteBtn.textContent = 'üóë';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selections.splice(i, 1);
                    updateSelectionsUI();
                    draw();
                    showToast('Selection deleted');
                });

                div.appendChild(nameSpan);
                div.appendChild(coordsSpan);
                div.appendChild(duplicateBtn);
                div.appendChild(deleteBtn);
                selectionsDiv.appendChild(div);
            });
        }

        copyAllBtn.addEventListener('click', () => {
            if (selections.length === 0) {
                showToast('No selections');
                return;
            }

            const text = selections.map(sel =>
                `    ${sel.name}: ${formatCoords(sel.x, sel.y, sel.w, sel.h)},`
            ).join('\n');

            copyToClipboard(`const spriteRegions = {\n${text}\n};`);
        });

        clearAllBtn.addEventListener('click', () => {
            if (selections.length === 0) return;
            if (confirm('Delete all selections?')) {
                selections = [];
                updateSelectionsUI();
                draw();
                showToast('Selections cleared');
            }
        });

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('Copied!');
                }).catch(() => fallbackCopy(text));
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('Copied!');
            } catch (err) {
                showToast('Copy failed');
            }
            document.body.removeChild(textarea);
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        window.addEventListener('resize', () => {
            resizeCanvases();
            draw();
        });

        container.addEventListener('contextmenu', e => e.preventDefault());

        resizeCanvases();
    </script>
</body>
</html>
